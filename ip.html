<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
    <link rel="stylesheet" href="css/estilos.css">
    <link rel="stylesheet" href="css/prism.css">
    <link rel="stylesheet" href="css/all.css">
    <link  rel="icon"   href="img/favicon.png" type="image/png" />
    <title>TCP/IP, Sockets UDP</title>
</head>
<body>

<div class="container-head">
    <div class="logos">
        <a href="index.html" class="logo"><img src="img/logo-utet.png" alt="logo" width="100px" height="84px" ></a>
    </div> 
</div>

      

<header>
    <div class="container-menu logo-nav-contenedor">
        <span class="menu-icon"><i class="fas fa-bars"></i></span>
        <nav class="navegacion">
            <ul class="show">
                <strong><li><a href="index.html">Inicio</a></li></strong>
                <strong><li><a href="Presentaciones.html">Presentaciones</a></li></strong>
                <strong><li><a href="Videos.html">Videos</a></li></strong>
               
            </ul>
        </nav>
      </div>
</header>

<div class="container-general">
    <main>
    <div class="container-cuerpo">
    <div class="columna_izquierda">
        <div class="contenido_1">
            <strong><h3>Temas</h3></strong>
        </div>
        <div class="contenido_2">
            <nav class="navegacion_2">
                <ul class="show_2">
                 <!-- <li><a href="#"><i class="fas fa-sign-in-alt"></i>Expresiones Lambda</a></li> -->
                 <li><a href="Expresiones_Lambda.html"><i class="fas fa-sign-in-alt"></i>Expresiones Lambda</a></li> 
                 <li><a href="Hilo_Sincronizacion.html"><i class="fas fa-sign-in-alt"></i>Hilos y Sincronización</a></li>
                 <li><a href="Metodos_estaticos.html"><i class="fas fa-sign-in-alt"></i>Métodos Estáticos</a></li>
                 <li><a href="ForkJoin.html"><i class="fas fa-sign-in-alt"></i>ForkJoin</a></li>
                 <li><a href="JavaStreams.html"><i class="fas fa-sign-in-alt"></i>Java Streams</a></li>
                 <li><a href="ip.html"><i class="fas fa-sign-in-alt"></i>TCP/IP, Sockets UDP</a></li>
                 <li><a href="MapReduce.html"><i class="fas fa-sign-in-alt"></i>MapReduce</a></li>
                 <li><a href="TCP.html"><i class="fas fa-sign-in-alt"></i>Sockets TCP</a></li>
                 <li><a href="Contenedores.html"><i class="fas fa-sign-in-alt"></i>Contenedores</a></li>
                 <li><a href="MaquinaVirtual.html"><i class="fas fa-sign-in-alt"></i>Maquina virtual</a></li>
                 <li><a href="VirtualBox.html"><i class="fas fa-sign-in-alt"></i>Virtual Box</a></li>
                 <li><a href="Docker.html"><i class="fas fa-sign-in-alt"></i>Docker</a></li>
                 <li><a href="InyeccionDependencia.html"><i class="fas fa-sign-in-alt"></i>InyeccionDependencia</a></li>
		 <li><a href="Thymeleaf.html"><i class="fas fa-sign-in-alt"></i>Thymeleaf</a></li>
                </ul>
            </nav>
        </div>
    </div>
    
    <section class="columna_derecha">
        <div text align="center"><h2>TCP/IP, Sockets UDP</h2></div>
        <p> Actualmente la mayoría de ordenadores están conectados a alguna red (internet, intranet, etc.) y casi todos lo hacen utilizando
             el modelo TCP/IP. Este modelo es un protocolo para comunicación en redes que permite que un equipo pueda comunicarse
              dentro de una red. Está basado en el modelo teórico OSI de capas con la que comparte 4 de ellas; sin embargo,
              ofrece muchas más opciones y es un modelo práctico.</p>
    
    <p>A día de hoy no podemos concebir el mundo de la informática sin Internet, ya que las redes son uno de los componentes básicos sobre
         los que se sostiene la sociedad actual. Por eso hoy hablaremos de los que seguramente son los dos protocolos más importantes en las redes actuales,
          el protocolo TCP/IP, del cual hablaremos más detalladamente.</p>
    
    <p>Por fortuna o desgracia dependemos casi totalmente de Internet. Por ahí compramos, consumimos contenido, entablamos “amistad” con otras personas, e 
        incluso muchos vivimos de ello. Un componente que sin embargo es también intrusivo en la vida personal necesita de protocolos e infraestructuras que nos protejan a los usuarios en la medida de lo posible.</p>
    
      <strong><p>Qué es TCP/IP</p></strong> 
    
       <p>Cuando hablamos de TCP/IP normalmente nos estamos refiriendo al modelo TCP/IP, un modelo que describe y de alguna forma clasifica los protocolos de red al igual que hace el modelo OSI. Pero también se trata 
           de dos protocolos de red que operan a distintos niveles o capas y cuya existencia es imprescindible en lo que hoy se conoce como red de intercambio de paquetes.</p>
        
        <div text align="center"><img src="img/protocolo-TCP-IP-03.png" alt="" class="imagen"></div>

        <p>TCP/IP es un conjunto o familia de protocolos, desarrollados para permitir que las computadoras compartan recursos en una redes
            Algunos de estos protocolos son de base y se utilizan para una gran cantidad de tareas. Estos incluyen IP,TCP y UDP.  </p>
        
         <p>En la capa de aplicación, algunos protocolos muy usados son HTTP para las aplicaciones y servicios web, o RTP para streaming de audio o video
          <p>*En la capa de transporte, HTTP usará TCP, RTP usará UDP(o TCP)</p> </p>
          <p>*EN la capa de Internet, tanto TCP como UDP usarán IP, aunque hay otros protocolos como ICMP, que utiliza el clásico PING
        </p>
        <strong><p>Modelo de red TCP/IP</p></strong>
    
        <p>TCP/IP significa Protocolo de Control de Transmisión/Protocolo de Internet en español. Hablamos de TCP/IP unidos para referirnos a un modelo de red el cual fue desarrollado por Vinton Cerf y Robert E. Kahn en 1970.
             Fueron dos de los pesos pesados que trabajaron sobre la red ARPANET, la primera red de intercambio de datos de área amplia o WAN que fue un encargo del Departamento de Defensa de los estados Unidos.</p>
           
        <p>TCP/IP identifica los protocolos utilizamos en las redes y describe el conjunto de guías y reglas generales que hacen posible que un equipo sea capaz de intercambiar información en una red. El modelo asegura una
        conexión punto a punto y define como deben ser formateados, direccionados transmitidos y enrutados los datos.</p>
        
        <div text align="center"><img src="img/protocolo tcp ip 2.png" alt="" class="imagen"></div>

        <strong><p>El modelo TCP/IP se divide en 4 capas distintas que se definen así:</p></strong>
        
       <strong><p><li>Capa 1 o de acceso al medio</li></p></strong> 
        <p>Esta capa define el acceso físico de los equipos conectados a la red y los protocolos que en él intervienen. También se denomina capa de enlace de red porque incluye todos los hosts accesibles en una red de área local. 
            Esta también define la topología de la red, estrella, malla, anillo, etc, y como se mueven los paquetes entre las interfaces de la capa de Internet.</p>
        
        <p>A pesar de que está definido sobre una red de área local, TCP/IP es extensible a toda la red global, por estar diseñado de forma independiente del hardware que compone la red. Por ello redes de cables de pares trenzados, 
            coaxiales, fibra óptica o incluso redes inalámbricas entran dentro de este modelo y utilizando estos protocolos.</p>
       
        <p>Esta capa de enlace tiene las mismas funciones que la capa 2 o capa de enlace del modelo OSI, no por anda se llaman igual.</p>
        
       <strong><p><li>Capa 2 o de Internet</li></p></strong> 
        <p>Una de las capas más importantes en el modelo por ocuparse de la estructura del paquete de datos básico que circula por la red y de cómo enviarlos a través de la red. La capa de Internet define entonces cómo será el
             enrutamiento de los datagramas a partir de la administración de las direcciones IP.</p>

        <p>Por esto la otra función básica de la capa es la identificación del host en la red mediante una dirección y el direccionamiento de estos datagramas dando saltos entre enrutadores hasta llegar al destino. Es aquí en donde 
            trabaja el protocolo IP, así como otros protocolos muy conocidos como IGMP, ICMP o ARP.</p>
       
         <p>Esta capa hace las mismas funciones que la capa 3 del modelo OSI, también llamada capa de red.</p>   

        <strong><p><li>Capa 3 o de transporte</li></p></strong>
        <p>En la capa de transporte es donde tienen protagonismo los puertos lógicos de un router, ya que es la capa que establece los canales básicos que utilizarán las aplicaciones para intercambiar información entre dos puntos. 
            Por tanto, la capa define como será la conexión de un host a otro, asociando un puerto a un tipo de aplicación a su vez con un tipo de datos.</p>

         <p>En esta capa hay protocolos que se encargan de la segmentación de paquetes, del control de errores y el control de flujo de estos. El protocolo TCP opera en esta capa, siendo un de tipo orientado a conexión, mientras que el
              otro quizás más importante es el UDP que no es orientado a conexión. Veremos luego sus diferencias.</p>   
         
         
        <p>Esta capa de transporte hace más o menos las mismas funciones que la capa de transporte del modelo OSI.</p> 

        <strong><p><li>Capa 4 o de aplicación</li></p></strong>
        <p>Esta es la capa más cercana al usuario, y la que define los protocolos que usarán las aplicaciones que proporcionan servicios al usuario. Estas aplicaciones se comunican entre ellas con la estructura definida en las 3 capas
             inferiores, proporcionando su propio encapsulamiento según tipo de aplicación que sea y el tipo de dato con el que trabaja.</p>
         
        <p>En esta capa es donde encontramos algunos protocolos muy famosos como son el HTTP de las páginas web, el FTP para la transferencia de archivos, DHCP como protocolo de configuración dinámica de host o el SMTP para la transferencia de correos.</p>

        <p>Corresponde a las capas 5, 6 y 7 del modelo OSI.</p>
       

        <strong><h3>User Datagram Protocol</h3></strong>
      <P>El protocolo UDP (User Datagram Protocol) es un protocolo de transporte sin conexión y por lo tanto no seguro. 
           Realiza una pequeña comprobación de errores y no añade nada a los servicios IP excepto para proporcionar comunicación de proceso 
           a proceso en lugar de comunicación host a host.</P>

       <p>UDP es un protocolo simple con una sobrecarga mínima. Si un proceso desea enviar un mensaje pequeño y no le importa mucho 
            la fiabilidad, puede utilizar UDP. El envío de un mensaje utilizando UDP tarda mucho menos tiempo que utilizando TCP.</P>
       <strong><p>Nota:</strong> UDP es un protocolo adecuado para aplicaciones multimedia y multidifusión.</p>
       <div text align="center"><img src="img/User-Datagram-Protocol-3.png" class="imagen"></div>

       <strong><h4>Protocolo de control de transmisiones</h4></strong> 
      <P>El protocolo de control de transmisiones (TCP) es un protocolo de capas de transporte fiable pero complejo. TCP añade a IP 
      características orientadas a la conexión y fiabilidad.</P>

     <p>TCP es un servicio de entrega de secuencias fiable que garantiza la entrega de una secuencia de datos que se envía de un host a otro sin la duplicación ni la pérdida de datos. Puesto que la transferencia de paquetes no segura, se utiliza una técnica que se conoce como reconocimiento positivo con retransmisión para garantizar la fiabilidad de las transferencias de paquetes. 
       Esta técnica fundamental requiere que el receptor responda con un mensaje de acuse de recibo cuando recibe los datos.</P>

     <p>El emisor mantiene un registro de cada paquete que envía y espera a recibir un acuse de recibo antes de enviar el siguiente paquete.<p/>
        <p>El emisor también mantiene un temporizador de cuando el paquete se ha enviado y retransmite un paquete si el temporizador caduca.<p/> 
            <p> El temporizador es necesario en el caso de que un paquete se pierda o esté dañado.<p/>

Designación de cliente o servidor
Con los sockets, debe especificar qué final de los dos procesos inicia la conversación (el cliente) y qué proceso espera a que se inicie su igual (el servidor).

Conexiones
La conexión de un igual con otro la establece, es decir, la inicia un cliente o la acepta un servidor, solamente cuando un suscriptor o un publicador basado en pruebas se ejecuta en Rational Integration Tester. La conexión debe existir durante la prueba y es compartida por todas las operaciones de mensajería subsiguientes dentro de la misma secuencia de prueba. Si la secuencia de prueba ejecuta una prueba hija, la conexión se pasa a la hija para que pueda comunicarse con el mismo igual.

       <strong><h4>Sockets datagram (UDP)</h4></strong>
    

        <p>Los sockets datagram se basan en el protocolo UDP y ofrecen un servicio de transporte sin conexión. Es decir, podemos mandar información a un destino sin necesidad de realizar una conexión previa. El protocolo UDP es más eficiente que el TCP,
             pero tiene el inconveniente de que no se garantiza la fiabilidad. Además, los datos se envían y reciben en datagramas (paquetes de información) de tamaño limitado. La entrega de un 
             datagrama no está garantizada: estos pueden duplicarse, perderse o llegar en un orden diferente del que se envió.</p>

        <p>La gran ventaja de este tipo de sockets es que apenas introducen sobrecarga sobre la información transmitida. Además, los retrasos introducidos son mínimos, lo cual los hace especialmente interesantes para aplicaciones en tiempo real, como la transmisión
             de audio y vídeo sobre Internet. Sin embargo, presentan muchos inconvenientes para el programador: cuando transmitimos un datagrama no tenemos la certeza de que este llegue a su destino, por lo que, si fuera necesario, tendríamos que implementar nuestro
              propio mecanismo de control de errores. Otro inconveniente es el hecho de que existe un tamaño máximo de datagrama: unos 1500 bytes dependiendo de la implementación. Si la información a enviar es mayor, tendremos que fraccionarla y enviar varios datagramas
               independientes. En el destino tendremos que concatenarlos en el orden correcto.</p>
         
        <strong><h4>Datagram Sockets</h4></strong>

            <p>Un conector de datagrama proporciona una interfaz de intercambio de datos simétrica sin necesidad de establecer una conexión.
                 Cada mensaje lleva la dirección de destino. 
                La siguiente figura muestra el flujo de comunicación entre el servidor y el cliente.</p>
                <div text align="center"><img src="img/sockets.png" alt=""  class="imagen"></div>
                <strong><p>El siguiente código de ejemplo muestra cómo enviar una llamada de Internet creando un conector, 
                    vinculando un nombre al conector y enviando el mensaje al conector</p></strong>
                    <pre class="language-java"><code>
#include < sys / types.h>
#include < sys / socket.h>
#include < netinet / in.h>
#include < netdb.h>
#include < stdio.h>
#define DATA "El mar está en calma, la marea está llena..."   
/ *
    * Aquí envío un datagrama a un receptor cuyo nombre obtengo de
    * los argumentos de la línea de comandos. La forma de la línea de comando es:
    * dgramsend nombre de host número de puerto
    * /
principal (int argc, char * argv [])
{
    int calcetín, errnum;
    struct sockaddr_in6 nombre;
    struct hostent * hp;
    / * Crear conector en el que enviar. * /
    calcetín = enchufe (AF_INET6, SOCK_DGRAM, 0);
    si (calcetín == -1) {
        perror ("abrir conector de datagrama");
        salida (1);
    }
    / *
        * Construya el nombre, sin comodines, del socket para `` enviar ''
        * a. getinodebyname devuelve una estructura que incluye la red
        * dirección del host especificado. El número de puerto se toma de
        * la línea de comando.
        * /
    hp = getipnodebyname (argv [1], AF_INET6, AI_DEFAULT, & errnum);
    if (hp == (struct hostent *) 0) {
        fprintf (stderr, "% s: host desconocido \ n", argv [1]);
        salida (2);
    }
    bzero (& nombre, tamaño de (nombre));
    memcpy ((char *) & name.sin6_addr, (char *) hp-> h_addr,
        hp-> h_length);
    name.sin6_family = AF_INET6;
    name.sin6_port = htons (atoi (argv [2]));
    /* Enviar mensaje. * /
    if (enviar a (calcetín, DATOS, tamaño de DATOS, 0,
        (struct sockaddr *) & nombre, tamaño del nombre) == -1)
        perror ("enviando mensaje de datagrama");
    cerrar (calcetín);
    salir (0);
}
                    </code></pre>
         <p> <strong> Fuente: </strong>tutorialspoint.com/java8/java8_streams.htm</p> 
        
      </section>
    

<div class="container_busqueda">
   
    <div id="search-wrapper">
        <input type="search" id="search" placeholder="Buscar"/>
        <i class="fa fa-search"></i>
      </div>
    <ul id="resultado" class="lista_busqueda">
        
    </ul>
</div>
</div>
</div>
</main>


<footer>
    <div class="container-pie">
        <div class="copyright">
           <p>&copy; 2020 Página realizada por estudiantes de la Universidad UTE.</p> 
        </div>
    </div>
</footer>
</div>

<script src="js/jQuery.js"></script>
<script src="js/scripts.js"></script>
<script src="js/prism.js"></script>



<script>
    const temas = [  /*Cargar aqui enlaces para la busqueda con el mismo formato.*/
    {titulo: '<a href="Expresiones_Lambda.html">Expresiones Lambda</a>'},   
        {titulo: '<a href="Metodos_estaticos.html">Métodos Estáticos</a>'},   
        {titulo: '<a href="ForkJoin.html">ForkJoin</a>'}, 
        {titulo: '<a href="Hilo_Sincronizacion.html">Hilos y Sincronización</a>'},
        {titulo: '<a href="JavaStreams.html">Java Streams</a>'},    
        {titulo: '<a href="ip.html">TCP/IP, Sockets UDP</a>'}, 
        {titulo: '<a href="MapReduce.html">MapReduce</a>'}, 
        {titulo: '<a href="TCP.html">Sockets UTP</a>'}, 
        {titulo: '<a href="Contenedores.html">Contenedores</a>'}, 
		{titulo: '<a href="VirtualBox.html">VirtualBox</a>'}, 
        {titulo: '<a href="Docker.html">Docker</a>'}, 
        {titulo: '<a href="MaquinaVirtual.html">Máquina Virtual </a>'}, 
        {titulo: '<a href="InyeccionDependencia.html">Inyeccion de Dependencias </a>'}, 
    ]
    const formulario= document.querySelector('#search');
    const boton= document.querySelector('#boton');
    const resultado=document.querySelector('#resultado');

    const filtrar = ()=>{
       resultado.innerHTML='';

       const texto = formulario.value.toLowerCase();
       for(let tema of temas ){
           let titulo=tema.titulo.toLowerCase();
           if(titulo.indexOf(texto) !== -1){
               
                resultado.innerHTML += '<li>'+tema.titulo+'</li>'
         }
        }
        if(resultado.innerHTML===''){
            resultado.innerHTML += '<li>Enlace no Encontrado...</li>'
        }
    }
    //boton.addEventListener('click',filtrar)
    formulario.addEventListener('keyup',filtrar);
   
    
</script>
</body>
</html>
